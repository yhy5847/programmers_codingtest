import java.util.ArrayList;

class KeyLock {
    public static void main(String[] args) {

    }
    //key 배열의 1(돌기)위치 기록
    public int[] key1find(int[][] key){
        ArrayList<Integer> key1find = new ArrayList<Integer>();
            for(int i = 0; i < key.length; ++i){
                for(int j = 0; j < key.length; ++j){
                    if(key[i][j] == 1) {
                        key1find.add()
                    }
                }
            }
    }
    
}



/* 
키를 돌리는 알고리즘
록과 비트연산자로 비교했을때 겹치는 숫자 나오면 펄스나오는 알고리즘
배열을 위 아래로 밀면서 맞는경우를 찾는 알고리즘
[1][0]이 회전하면 [0][1]됨
또 회전하면 [1][2]
또 하면 [2][1]
10 > 01 > 12 > 21
키의 시작점 자체를 왼쪽 위로 몰아넣고 경우의 수 다 찾으면서 답 도출
if문으로 값을 비교한다. 단 비교할 값들중에 1이 할당되어있지 않으면 배제한다
값을 옆으로 밀면서 비교한다 100이면 [2]와 [0]부터 비교 시작
이동시킨다는 개념이 아니라 하나하나 비교한다는 느낌으로 생각해보자
그렇다면 제일 끝의 끝번째 배열과 제일 첫번째의 첫번째 개념과 비교한다

@@아이디어@@
- 락에 홈이 있는 부분둘래로 사각형으로 잘라서 그것만 열쇠와 비교해서 경우의 수를 줄이는 방법?
- 키 배열 모양을 기록 > 키부분의 1(돌기)부분의 배열을 골라냄 > 그 배열만 락의 배열과 대조하면서 0(홈)부분을 찾으면 >
키 배열 모양을 불러와서 90도씩 회전시키며 비교 > 맞으면 break 틀리면 계속함

예를 들어 둘다 3x3이라면 키의 [2][2]부분과 록의 [0][0]부분을 비교하면서 내려간다
한줄의 배열을 록 기준으로 모두 비교하는 공식이다
규칙성을 보면 [2][2]를 록의 첫 열의 0,1,2행과 비교한다

-키의 2행의 배열들과 락의 0행을 비교-
[2][2] [0][0]
[2][2] [1][0]   [1][2] [0][0]
[2][2] [2][0]   [1][2] [1][0]   [0][2] [0][0]
                [1][2] [2][0]   [0][2] [1][0]
                                [0][2] [2][0]

-키의 1행의 배열들과 락의 0행을 비교, 키의 2행의 배열들과 락의 1행을 비교-
[2][1] [0][0]                                       [2][2] [0][1]
[2][1] [1][0]   [1][1] [0][0]                       [2][2] [1][1]   [1][2] [0][1]
[2][1] [2][0]   [1][1] [1][0]   [0][1] [0][0]       [2][2] [2][1]   [1][2] [1][1]   [0][2] [0][1]
                [1][1] [2][0]   [0][1] [1][0]                       [1][2] [2][1]   [0][2] [1][1]
                                [0][1] [2][0]                                       [0][2] [2][1]

-키의 0행의 배열들과 락의 0행을 비교, 키의 1행의 배열들과 락의 0행을 비교, 키의 2행의 배열들과 락의 2행을 비교 -
[2][0] [0][0]                                       [2][1] [0][1]                                       [2][2] [0][2]
[2][0] [1][0]   [1][0] [0][0]                       [2][1] [1][1]   [1][1] [0][1]                       [2][2] [1][2]   [1][2] [0][2]
[2][0] [2][0]   [1][0] [1][0]   [0][0] [0][0]       [2][1] [2][1]   [1][1] [1][1]   [0][1] [0][1]       [2][2] [2][2]   [1][2] [1][2]   [0][2] [0][2]
                [1][0] [2][0]   [0][0] [1][0]                       [1][1] [2][1]   [0][1] [1][1]                       [1][2] [2][2]   [0][2] [1][2]
                                [0][0] [2][0]                                       [0][1] [2][1]                                       [0][2] [2][2]

 */